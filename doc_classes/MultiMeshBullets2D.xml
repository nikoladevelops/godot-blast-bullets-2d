<?xml version="1.0" encoding="UTF-8" ?>
<class name="MultiMeshBullets2D" inherits="MultiMeshInstance2D" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		This class is only meant to be inherited by other C++ classes. Never use this by its own. Always use the [BulletFactory2D], that's the only proper way.
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="activate_bullet">
			<return type="void" />
			<param index="0" name="bullet_index" type="int" />
			<param index="1" name="collision_amount" type="int" default="0" />
			<description>
				Activate a specific bullet from the multimesh, making it active and visible on screen.

				You can also provide a [code]collision_amount[/code], which is how many times this bullet can collide before it gets disabled.
				
				If you provide 0, a negative value or a value greater than [member bullet_max_collision_amount], then the bullet will be able to collide [member bullet_max_collision_amount] times before it gets disabled.
				
				It's valid to set it to a value that is less than [member bullet_max_collision_amount].
			</description>
		</method>
		<method name="disable_bullet">
			<return type="void" />
			<param index="0" name="bullet_index" type="int" />
			<description>
				Disable a specific bullet from the multimesh
			</description>
		</method>
		<method name="get_all_bullets_status">
			<return type="bool[]" />
			<description>
				Get the status of all bullets inside the multimesh - whether they are enabled (active and visible on screen) or disabled (inactive and invisible)
			</description>
		</method>
		<method name="get_amount_bullets" qualifiers="const">
			<return type="int" />
			<description>
				Get the amount of bullets inside the multimesh
			</description>
		</method>
		<method name="is_bullet_status_enabled">
			<return type="bool" />
			<param index="0" name="bullet_index" type="int" />
			<description>
				Check the status of a specific bullet - whether it is enabled (active and visible on screen) or disabled (inactive and invisible)
			</description>
		</method>
		<method name="multimesh_attach_time_based_function">
			<return type="void" />
			<param index="0" name="time" type="float" />
			<param index="1" name="callable" type="Callable" />
			<param index="2" name="repeat" type="bool" />
			<param index="3" name="execute_only_if_multimesh_is_active" type="bool" />
			<description>
				Attaches a callable that gets executed after a certain amount of time.

				[code]time[/code] - the time in seconds after which the callable will be executed.
				[code]callable[/code] - the callable that will be executed. It can be a lambda, a function or a method from another object.
				[code]repeat[/code] - if set to true, then the callable will be executed every [code]time[/code] seconds.
				[code]execute_only_if_multimesh_is_active[/code] - if set to [code]true[/code], then the callable will only be executed if the multimesh is active in the scene tree (if it has at least a single bullet that has not yet been disabled).
				If you wish to execute the callable regardless of the multimesh being active or not, then set this parameter to [code]false[/code].
				Note: For this to take effect ensure that the [member is_multimesh_auto_pooling_enabled] property is set to false - this is because auto pooling clears any callables in order to re-use the multimesh later completely reset.

				If you want to be able to detach the callable, then make sure that it is clearly declared outside as a variable or you could even use a normal Godot function.

				Callables that execute bullet related functions have no need of using call_deferred(), since all attached callables are executed at the end of the frame by default for safety.
			</description>
		</method>
		<method name="multimesh_detach_all_time_based_functions">
			<return type="void" />
			<description>
				Detaches all time based functions that were previously attached.
			</description>
		</method>
		<method name="multimesh_detach_time_based_function">
			<return type="void" />
			<param index="0" name="callable" type="Callable" />
			<description>
				Detaches a specific time based callable. This will work as long as the callable you are trying to detach
				was previously saved in a variable or defined as a normal Godot function.
			</description>
		</method>
	</methods>
	<members>
		<member name="bullet_max_collision_amount" type="int" setter="set_bullet_max_collision_amount" getter="get_bullet_max_collision_amount" default="1">
			How many times a bullet can collide before it gets disabled. If you set to 0, then the bullet will NEVER get disabled due to collisions.
		</member>
		<member name="bullets_custom_data" type="Resource" setter="set_bullets_custom_data" getter="get_bullets_custom_data">
			You can edit the custom bullets data that the bullets multimesh was spawned with
		</member>
		<member name="is_life_time_infinite" type="bool" setter="set_is_life_time_infinite" getter="get_is_life_time_infinite" default="false">
			If you set to true, then the lifetime will be ignored and bullets will never be destroyed.

			Warning: If you don't implement "collision walls" or anything else to intercept/collide with the bullets, then they will truly live forever in your memory and you will experience lag.
		</member>
		<member name="is_multimesh_auto_pooling_enabled" type="bool" setter="set_is_multimesh_auto_pooling_enabled" getter="get_is_multimesh_auto_pooling_enabled" default="true">
			Whether the multimesh auto pooling is enabled or not.

			When enabled, the multimesh will automatically get removed from the scene tree when all bullets are disabled, and it will also clear all time based callables.
			When disabled, you are the one responsible for re-using the multimesh or clearing any time based callables that you might have attached with [member attach_time_based_function].
			
			If you are going to save your multimesh bullets in an array, then it's probably best to disable auto pooling and manage the instances yourself.
		</member>
	</members>
</class>
